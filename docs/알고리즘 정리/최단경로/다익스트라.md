다익스트라
=
- 그리디 + DP
- 현재 위치에서 모든 노드까지의 최소 경로를 알 수 있다. 
- 음의 가중치 불가 (있으면 벨만 포드나 플로이드 워셜 사용할 것)
## 음의 가중치 사용하면 안되는 이유
![image](https://github.com/user-attachments/assets/a9e5dd81-6cda-4ca3-91bc-fdb0fdc72ec6)
- 그리디 방식으로 동작하기 때문에
  - 최소 거리에 최소 거리를 붙여가면서 경로를 탐색
  - 방문처리를 했을 때보다 더 빠른 경로가 없을 것, 불필요한 재방문을 방지하기 위해 visited 배열을 둠
    - 하지만, 다른 경로로 갈 때 더 빠를 수 있으니까 visited 두지 않기
  - visited 없애면 음수 가중치 했을 때의 최단 경로도 구할 수 있지않을까? 
    - 만약, 음수 가중치에 순환이 있다면 무한 루프에 빠질 수 있다. 
- 위의 그래프 를 사용하는 경우, A &rarr; B &rarr; C 의 경로를 찾지 못함

## 자바 구현

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.PriorityQueue;
import java.util.StringTokenizer;

public class Main {
  static ArrayList<Node>[] graph;
  static int[] dist;
  static int INF = Integer.MAX_VALUE;

  public static void main(String[] args) throws IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    int N = Integer.parseInt(br.readLine());
    int M = Integer.parseInt(br.readLine());

    graph = new ArrayList[N + 1];
    for (int i = 1; i < N; i++) {
      graph[i] = new ArrayList<>();
    }

    StringTokenizer st;
    int v, w, cost;
    for (int i = 0; i < M; i++) {
        st = new StringTokenizer(br.readLine());
        v = Integer.parseInt(st.nextToken());
        w = Integer.parseInt(st.nextToken());
        cost = Integer.parseInt(st.nextToken());
        graph[v].add(new Node(w, cost));
    }
    dist = new int[N + 1];
    Arrays.fill(dist, INF);

    int start = Integer.parseInt(br.readLine());
    Dijkstra(n, start);
  }

  public static void Dijkstra(int n, int start) {
    dist[start] = 0;

    PriorityQueue<Node> pq = new PriorityQueue<>();
    pq.offer(new Node(start, 0));

    while (!pq.isEmpty()) {
      Node current = pq.poll();
      int nowVertex = current.index;
      

      for (Node next : graph[nowVertex]) {
        if (dist[next.index] > dist[nowVertex] + next.cost) {
          dist[next.index] = dist[nowVertex] + next.cost;
          pq.offer(new Node(next.index, dist[next.index]));
        }
      }

      for (int i : dist) {
        System.out.println(i == INF ? -1 : i);
      }
    }

  }
}


class Node implements Comparable<Node> {
  int index;
  int cost;

  public Node(int index, int cost) {
    this.index = index;
    this.cost = cost;
  }

  @Override
  public int compareTo(Node o) {
    return Integer.compare(this.cost, o.cost);
  }
}
```
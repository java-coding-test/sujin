플로이드 워셜 알고리즘
=
## 핵심
- 최단 경로 알고리즘
- 모든 노드에 대하여 다른 모든 노드로의 최단 거리 구하기
- DP + 인접 행렬 사용
- 음수 가중치 있어도 수행 가능
- 음의 사이클은 존재하지 않아야 함. 
- 3중 for 문 사용
  1. 단계적 진행 (경유지 0 ~ n - 2)
  2. 출발지
  3. 목적지
- 시간 복잡도 O(n^3),  공간 복잡도 O(n^2)

### 핵심 이론
```
distance[A][B] = Math.min(distance[A][B], distance[A][C] + distance[C][A]);
```

## 주의
### 배열 초기화 값
- 배열을 큰 값으로 초기화 할 대, Integer.MAX_VALUE 말고 10억 정도의 수로 초기화 할 것.
- 값을 더해서 비교하는 연산 수행 &rarr; 오버플로우 발생 가능성
### 음수 사이클
- 음수 사이클이 존재하면 최단 경로가 무한히 작아짐 &rarr; 알고리즘이 제대로 동작하지 않는다. 
- 자기자신과의 거리 `dist[s][s]` 를 0으로 초기화
- 이 값이 달라지면 음의 사이클이 존재하는 것
- 보통의 문제는 음의 사이클이 존재하지 않지만 문제를 잘 읽고 존재할 수 있는 경우라면 검출 과정을 거쳐야 한다.
### 입력값에 중복된 경로
- 경로가 두 번 나올 수도 있으니 기존의 cost와 비교해서 작은값으로 대입하기!!
### `graph[i][i]` 는 꼭 0으로 초기화 할 것. 
- 안그러면 다른 경유지를 거쳐서 가는 최소 값을 구하게 됨

## 자바 코드

```java
import java.io.*;
import java.util.Arrays;
import java.util.StringTokenizer;

public class Main {
    static final int INF = 1_000_000_000;
    static int n, m;        // 정점의 개수, 간선의 개수
    static int[][] graph;   // 인접 행렬

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
        n = Integer.parseInt(br.readLine());
        m = Integer.parseInt(br.readLine());

        graph = new int[n + 1][n + 1];

        for (int i = 0; i < n + 1; i++) {
            Arrays.fill(graph[i], INF);
        }

        StringTokenizer st;
        for (int i = 0; i < m; i++) {
            st = new StringTokenizer(br.readLine());
            int v = Integer.parseInt(st.nextToken());
            int w = Integer.parseInt(st.nextToken());
            int cost = Integer.parseInt(st.nextToken());

            graph[v][w] = cost;
        }

        floyd();

        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= n; j++) {
                if (i == j) bw.write("0 ");
                else if (graph[i][j] == INF) bw.write("INF ");
                else bw.write(graph[i][j] + " ");
            }
            bw.write("\n");
        }
        bw.close();
    }

    public static void floyd() {
        for (int k = 1; k <= n; k++) {
            for (int i = 1; i <= n; i++) {
                for (int j = 1; j <= n; j++) {
                    graph[i][j] = Math.min(graph[i][j], graph[i][k] + graph[k][j]);
                }
            }
        }
    }
}
```